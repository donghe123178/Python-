## Python对象的比较和拷贝

一、**赋值**:

在 Python 中，**对象的赋值就是简单的对象引用**，这点和 C++不同



二、**浅拷贝**(shallow copy):

浅拷贝会创建新对象，其内容非原对象本身的引用，而是原对象内第一层对象的引用。浅拷贝有三种形式:**切片操作**、**工厂函数**、**copy 模块中的 copy 函数**。


三、**深拷贝**(deep copy):

深拷贝只有一种形式，c**opy 模块中的 deepcopy()函数**。深拷贝和浅拷贝对应，深拷贝拷贝了对象的所有元素，包括多层嵌套的元素。因此，它的时间和空间开销要高。


四、拷贝的注意点:

1、对于**非容器类型**，如数字、字符，以及其他的“原子”类型，没有拷贝一说，产生的都是**原对象的引用**。
2、如果元组变量值包含原子类型对象，即使采用了深拷贝，也只能得到浅拷贝。

####  == 和 is

- == 操作符比较对象之间的值是否相等
- is 操作符比较的是对象的身份标识是否相等，即是否是同一个对象，是否指向同一个内存地址

```python
# 整型数字比较，python中只适用于 -5到256范围的数字
# python内部对-5到256的整型维持一个数组，起到一个缓存的作用，性能优化,在python解释器中是这样的
a = 10
b = 10
# 对象的赋值就是简单的对象引用
# 为10这个值开辟一块内存，变量a 和 b同时指向这块内存区域
a == b
True

id(a)
4427562448

id(b)
4427562448

a is b
True
# 
c = 257
d = 257
# 为两个257开辟了两块内存区域
a == b
True

id(c)
4473417552

id(d)
4473417584

c is d
False
# 在pycharm中
A = -7
B = -7
if A == B:
    print(True)
print(id(A), id(B))
# 输出
True
1840373880816 1840373880816
```

- is 操作符的速度效率通常要优于==，因为is操作符不能被重载，执行is操作只是简单的获取对象的ID，并进行比较，而等于操作符则会递归地遍历对象所有值，并逐一比较

- 当比较一个变量与一个单例时，通常使用is

```python

if a is None:
      ...

if a is not None:
      ...
```

#### 浅拷贝和深度拷贝

- 浅拷贝： 是指重新分配一块内存，创建一个新的对象，里面的元素是原对象中子对象的引用，因此，如果原对象中的元素是可变的，改变其也会影响拷贝后的对象，存在一定的副作用

```python
# 常见的浅拷贝方法
# 1.使用数据类型本身的构造器
l1 = [1, 2, 3]
l2 = list(l1)

l2
[1, 2, 3]

l1 == l2
True
# 重新分配了内存
l1 is l2
False
# 说明了l2是l1的浅拷贝
# 2.对于可变的序列，通过切片操作符完成浅拷贝
l1 = [1, 2, 3]
l2 = l1[:]

l1 == l2
True

l1 is l2
False
# 3.copy.copy(),适用于任何数据类型
import copy
l1 = [1, 2, 3]
l2 = copy.copy(l1)
# 4.特别注意元组，用tuple()或者切片操作符：，不会创建一份浅拷贝
# 返回一个指向相同元组的引用
t1 = (1, 2, 3)
t2 = tuple(t1)
# 注意，元组（1，2，3）只被创建一次
t1 == t2
True

t1 is t2
True
```

- 深度拷贝：重新分配一块内存，创建一个新的对象，并且将元对象中的元素，**以递归的方式，通过创建新的子对象拷贝到新对象中**，因此，新对象和原对象没有任何关联。另外，深度拷贝中会维护一个字典，记录已经拷贝的对象及其ID，来提高效率并放置无限递归的发生。

```python
# 深度拷贝
import copy
l1 = [[1, 2], (30, 40)]
l2 = copy.deepcopy(l1)
l1.append(100)
l1[0].append(3)

l1
[[1, 2, 3], (30, 40), 100]

l2 
[[1, 2], (30, 40)]
# 思考用一个深度拷贝，拷贝一个无限嵌套的列表，是否相等
import copy
x = [1]
x.append(x)
y = copy.deepcopy(x)
if x == y:
    print(True)
else:
    print(False)
# 运行报错：RecursionError: maximum recursion depth exceeded in comparison
```

